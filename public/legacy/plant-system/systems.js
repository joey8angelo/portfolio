const binary_o = {
  grammar: {
    F: [["F F", 1]],
    G: [["F [ + G ] [ - G ]", 1]],
  },
  axiom: "G",
  start_position: [0, 0, 0],
  start_rotation: [0, 0, -1, 0, 1, 0, 1, 0, 0],
  start_width: 1,
  start_color: [135, 62, 35],
  step_size: 2,
  angle: 45,
  width_increment: 0,
  starting_width_increment: 0,
  addressable_colors: [],
  min_w: 0,
};
let binary = new LSystem(
  binary_o.axiom,
  binary_o.grammar,
  new Vector3(...binary_o.start_position),
  new Mat3(binary_o.start_rotation),
  binary_o.start_width,
  new Vector3(...binary_o.start_color),
  binary_o.step_size,
  binary_o.angle,
  binary_o.width_increment,
  binary_o.starting_width_increment,
  binary_o.addressable_colors.map((c) => new Vector3(...c)),
  binary_o.min_w,
);

const koch_o = {
  grammar: {
    F: [["F b + F b - F b - F b + F", 1]],
  },
  axiom: "F",
  start_position: [0, 0, 0.5],
  start_rotation: [1, 0, 0, 0, 1, 0, 0, 0, 1],
  start_width: 1,
  start_color: [135, 62, 35],
  step_size: 3,
  angle: 90,
  width_increment: 1,
  starting_width_increment: 0,
  addressable_colors: [],
  min_w: 0,
};
let koch = new LSystem(
  koch_o.axiom,
  koch_o.grammar,
  new Vector3(...koch_o.start_position),
  new Mat3(koch_o.start_rotation),
  koch_o.start_width,
  new Vector3(...koch_o.start_color),
  koch_o.step_size,
  koch_o.angle,
  koch_o.width_increment,
  koch_o.starting_width_increment,
  koch_o.addressable_colors.map((c) => new Vector3(...c)),
  koch_o.min_w,
);

const sierpinski_o = {
  grammar: {
    F: [["F - G + F + G - F", 1]],
    G: [["G G", 1]],
  },
  axiom: "F - G - G",
  start_position: [0, 0, 0.5],
  start_rotation: [1, 0, 0, 0, 1, 0, 0, 0, 1],
  start_width: 0.01,
  start_color: [135, 62, 35],
  step_size: 0.01,
  angle: 120,
  width_increment: 0.1,
  starting_width_increment: 0,
  addressable_colors: [],
  min_w: 0,
};
let sierpinski = new LSystem(
  sierpinski_o.axiom,
  sierpinski_o.grammar,
  new Vector3(...sierpinski_o.start_position),
  new Mat3(sierpinski_o.start_rotation),
  sierpinski_o.start_width,
  new Vector3(...sierpinski_o.start_color),
  sierpinski_o.step_size,
  sierpinski_o.angle,
  sierpinski_o.width_increment,
  sierpinski_o.starting_width_increment,
  sierpinski_o.addressable_colors.map((c) => new Vector3(...c)),
  sierpinski_o.min_w,
);

const sierpinski_approx_o = {
  grammar: {
    F: [["G - F - G", 1]],
    G: [["F + G + F", 1]],
  },
  axiom: "F",
  start_position: [0, 0, 0.5],
  start_rotation: [1, 0, 0, 0, 1, 0, 0, 0, 1],
  start_width: 0.01,
  start_color: [135, 62, 35],
  step_size: 0.01,
  angle: 60,
  width_increment: 1,
  starting_width_increment: 0,
  addressable_colors: [],
  min_w: 0,
};
let sierpinski_approx = new LSystem(
  sierpinski_approx_o.axiom,
  sierpinski_approx_o.grammar,
  new Vector3(...sierpinski_approx_o.start_position),
  new Mat3(sierpinski_approx_o.start_rotation),
  sierpinski_approx_o.start_width,
  new Vector3(...sierpinski_approx_o.start_color),
  sierpinski_approx_o.step_size,
  sierpinski_approx_o.angle,
  sierpinski_approx_o.width_increment,
  sierpinski_approx_o.starting_width_increment,
  sierpinski_approx_o.addressable_colors.map((c) => new Vector3(...c)),
  sierpinski_approx_o.min_w,
);

const sierpinski_carpet_o = {
  grammar: {
    F: [["F + F - F - F - f + F + F + F - F", 1]],
    f: [["f f f", 1]],
  },
  axiom: "F + F + F + F",
  start_position: [0, 0, 0.5],
  start_rotation: [1, 0, 0, 0, 1, 0, 0, 0, 1],
  start_width: 1,
  start_color: [135, 62, 35],
  step_size: 0.1,
  angle: 90,
  width_increment: 1,
  starting_width_increment: 0,
  addressable_colors: [],
  min_w: 0,
};
let sierpinski_carpet = new LSystem(
  sierpinski_carpet_o.axiom,
  sierpinski_carpet_o.grammar,
  new Vector3(...sierpinski_carpet_o.start_position),
  new Mat3(sierpinski_carpet_o.start_rotation),
  sierpinski_carpet_o.start_width,
  new Vector3(...sierpinski_carpet_o.start_color),
  sierpinski_carpet_o.step_size,
  sierpinski_carpet_o.angle,
  sierpinski_carpet_o.width_increment,
  sierpinski_carpet_o.starting_width_increment,
  sierpinski_carpet_o.addressable_colors.map((c) => new Vector3(...c)),
  sierpinski_carpet_o.min_w,
);

const dragon_o = {
  grammar: {
    F: [["F + G", 1]],
    G: [["F - G", 1]],
  },
  axiom: "F",
  start_position: [0, 0, 0.5],
  start_rotation: [1, 0, 0, 0, 1, 0, 0, 0, 1],
  start_width: 0.1,
  start_color: [135, 62, 35],
  step_size: 0.1,
  angle: 90,
  width_increment: 0,
  starting_width_increment: 0,
  addressable_colors: [],
  min_w: 0,
};
let dragon = new LSystem(
  dragon_o.axiom,
  dragon_o.grammar,
  new Vector3(...dragon_o.start_position),
  new Mat3(dragon_o.start_rotation),
  dragon_o.start_width,
  new Vector3(...dragon_o.start_color),
  dragon_o.step_size,
  dragon_o.angle,
  dragon_o.width_increment,
  dragon_o.starting_width_increment,
  dragon_o.addressable_colors.map((c) => new Vector3(...c)),
  dragon_o.min_w,
);

const plant_o = {
  grammar: {
    X: [["F + [ [ X ] - X ] - F [ - F X ] + X", 1]],
    F: [["F F", 1]],
  },
  axiom: "- X",
  start_position: [0, 0, 0],
  start_rotation: [0, 0, -1, 0, 1, 0, 1, 0, 0],
  start_width: 0.1,
  start_color: [135, 62, 35],
  step_size: 0.1,
  angle: 25,
  width_increment: 1,
  starting_width_increment: 0,
  addressable_colors: [],
  min_w: 0,
};
let plant = new LSystem(
  plant_o.axiom,
  plant_o.grammar,
  new Vector3(...plant_o.start_position),
  new Mat3(plant_o.start_rotation),
  plant_o.start_width,
  new Vector3(...plant_o.start_color),
  plant_o.step_size,
  plant_o.angle,
  plant_o.width_increment,
  plant_o.starting_width_increment,
  plant_o.addressable_colors.map((c) => new Vector3(...c)),
  plant_o.min_w,
);

const my_plant_o = {
  grammar: {
    X: [
      ["F @ [ ! BRANCH X ] [ ! BRANCH X ] X LEAVES", 0.4],
      ["F @ [ ! BRANCH X ] [ ! BRANCH X ]", 0.1],
      ["F @ [ ! BRANCH X ] X LEAVES", 0.5],
    ],
    F: [
      ["F F", 0.15],
      ["F ! F", 0.25],
      ["F F F", 0.04],
      ["F ! F ! F", 0.06],
      ["F", 0.4],
      ["RIGHT_BEND F", 0.05],
      ["LEFT_BEND F", 0.05],
    ],
    G: [
      ["G G", 0.4],
      ["G ! G", 0.1],
      ["G G G", 0.15],
      ["G ! G ! G", 0.05],
      ["G", 0.4],
    ],
    RIGHT_BEND: [
      ["+", 0.2],
      ["+ G +", 0.3],
      ["+ G + G +", 0.5],
    ],
    LEFT_BEND: [
      ["-", 0.2],
      ["- G -", 0.3],
      ["- G - G -", 0.5],
    ],
    BRANCH: [["BRANCH_DIRECTION BRANCH_ANGLE", 1]],
    BRANCH_DIRECTION: [
      ["", 0.067],
      ["\\ \\ \\ \\ \\", 0.066],
      ["\\ \\ \\ \\ \\ \\ \\ \\ \\ \\", 0.066],
      ["\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\", 0.066],
      ["\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\", 0.066],
      [
        "\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\",
        0.066,
      ],
      [
        "\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\",
        0.066,
      ],
      [
        "\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\",
        0.066,
      ],
      ["/ / / / /", 0.066],
      ["/ / / / / / / / / /", 0.066],
      ["/ / / / / / / / / / / / / / /", 0.066],
      ["/ / / / / / / / / / / / / / / / / / / /", 0.066],
      ["/ / / / / / / / / / / / / / / / / / / / / / / / /", 0.066],
      ["/ / / / / / / / / / / / / / / / / / / / / / / / / / / / / /", 0.066],
      [
        "/ / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / / /",
        0.066,
      ],
    ],
    BRANCH_ANGLE: [
      ["+ + +", 0.3],
      ["+ + + + + +", 0.4],
      ["+ + + + + + + + +", 0.3],
    ],
    H_BRANCH_ANGLE: [
      ["+ + + + + +", 0.3],
      ["+ + + + + + + + + + +", 0.4],
      ["+ + + + + + + + + + + + + + + + +", 0.3],
    ],
    H_BRANCH: [["BRANCH_DIRECTION H_BRANCH_ANGLE", 1]],
    LEAVES: [
      ["[ H_BRANCH f f LEAF ] [ H_BRANCH f f LEAF ]", 0.1],
      ["[ H_BRANCH f f LEAF ]", 0.1],
      [
        "[ H_BRANCH f f LEAF ] [ H_BRANCH f f LEAF ] [ H_BRANCH f f LEAF ]",
        0.7,
      ],
      [
        "[ H_BRANCH f f LEAF ] [ H_BRANCH f f LEAF ] [ H_BRANCH f f LEAF ] [ H_BRANCH f f f LEAVES ]",
        0.1,
      ],
    ],
    LEAF: [["[ # # # # # # # # '1 @ ]", 1]],
  },
  axiom: "X",
  start_position: [0, 0, 0],
  start_rotation: [0, 0, -1, 0, 1, 0, 1, 0, 0],
  start_width: 1,
  start_color: [92, 58, 26],
  step_size: 0.1,
  angle: 5,
  width_increment: 0.03,
  starting_width_increment: 0.2,
  addressable_colors: [[38, 102, 39]],
  min_w: 0.1,
};
let my_plant = new LSystem(
  my_plant_o.axiom,
  my_plant_o.grammar,
  new Vector3(...my_plant_o.start_position),
  new Mat3(my_plant_o.start_rotation),
  my_plant_o.start_width,
  new Vector3(...my_plant_o.start_color),
  my_plant_o.step_size,
  my_plant_o.angle,
  my_plant_o.width_increment,
  my_plant_o.starting_width_increment,
  my_plant_o.addressable_colors.map((c) => new Vector3(...c)),
  my_plant_o.min_w,
);

const pentigree_o = {
  grammar: {
    F: [["F - F + + F + F - F - F", 1]],
  },
  axiom: "F - F - F - F - F",
  start_position: [0, 0, 0.5],
  start_rotation: [1, 0, 0, 0, -1, 0, 0, 0, 1],
  start_width: 1,
  start_color: [135, 62, 35],
  step_size: 0.05,
  angle: 72,
  width_increment: 1,
  starting_width_increment: 0,
  addressable_colors: [],
  min_w: 0,
};
let pentigree = new LSystem(
  pentigree_o.axiom,
  pentigree_o.grammar,
  new Vector3(...pentigree_o.start_position),
  new Mat3(pentigree_o.start_rotation),
  pentigree_o.start_width,
  new Vector3(...pentigree_o.start_color),
  pentigree_o.step_size,
  pentigree_o.angle,
  pentigree_o.width_increment,
  pentigree_o.starting_width_increment,
  pentigree_o.addressable_colors.map((c) => new Vector3(...c)),
  pentigree_o.min_w,
);

const bush_o = {
  grammar: {
    apex: [["[ branch / / / / / / branch / / / / / / / branch ]", 1]],
    branch: [["[ & stem apex leaves ]", 1]],
    stem: [
      ["F stem", 0.9],
      ["F leaf stem", 0.1],
    ],
    //F: [["stem / / / / / F", 1]],
    leaves: [["[ / / / / leaf / / / / leaf / / / / leaf / / / / leaf ]", 1]],
    leaf: [["[ + + / / '1 { - f f + f f + f f - | - f f + f f + f f } ]", 1]],
  },
  axiom: "apex",
  start_position: [0, 0, 0],
  start_rotation: [0, 0, -1, 0, 1, 0, 1, 0, 0],
  start_width: 0.2,
  start_color: [135, 62, 35],
  step_size: 0.1,
  angle: 22.5,
  width_increment: 1,
  starting_width_increment: 0,
  addressable_colors: [[38, 102, 39]],
  min_w: 0,
};
let bush = new LSystem(
  bush_o.axiom,
  bush_o.grammar,
  new Vector3(...bush_o.start_position),
  new Mat3(bush_o.start_rotation),
  bush_o.start_width,
  new Vector3(...bush_o.start_color),
  bush_o.step_size,
  bush_o.angle,
  bush_o.width_increment,
  bush_o.starting_width_increment,
  bush_o.addressable_colors.map((c) => new Vector3(...c)),
  bush_o.min_w,
);

const flower_plant_o = {
  grammar: {
    plant: [
      [
        "stem + @ [ plant + flower ] - - / / [ - - leaf ] stem [ + + leaf ] - [ plant flower ] + + plant flower",
        1,
      ],
    ],
    stem: [["F F seg [ / / & & leaf ] [ / / ^ ^ leaf ] F F seg", 1]],
    seg: [
      ["seg F F seg", 0.6],
      ["seg", 0.3],
      ["seg [ / / & & leaf ] [ / / ^ ^ leaf ] F F seg", 0.1],
    ],
    leaf: [
      [
        "[ '1 { + f f f f - f f f f - f f f f + | + f f f  f - f f f f - f f f f } ]",
        1,
      ],
    ],
    flower: [
      [
        "[ & & & pedicel / wedge / / / / wedge / / / / wedge / / / / wedge / / / / wedge ]",
        1,
      ],
    ],
    pedicel: [["F F F", 1]],
    wedge: [
      [
        "[ ^ F F '3 # # @ ] [ '2 { & & - - f f f f + + f f f f | - - f f f f + + f f f f } ]",
        1,
      ],
    ],
  },
  axiom: "plant",
  start_position: [0, 0, 0],
  start_rotation: [0, 0, 1, 0, 1, 0, 1, 0, 0],
  start_width: 0.05,
  start_color: [92, 58, 26],
  step_size: 0.05,
  angle: 18,
  width_increment: 0.01,
  starting_width_increment: 0,
  addressable_colors: [
    [38, 102, 39],
    [56, 20, 61],
    [163, 144, 20],
  ],
  min_w: 0,
};
let flower_plant = new LSystem(
  flower_plant_o.axiom,
  flower_plant_o.grammar,
  new Vector3(...flower_plant_o.start_position),
  new Mat3(flower_plant_o.start_rotation),
  flower_plant_o.start_width,
  new Vector3(...flower_plant_o.start_color),
  flower_plant_o.step_size,
  flower_plant_o.angle,
  flower_plant_o.width_increment,
  flower_plant_o.starting_width_increment,
  flower_plant_o.addressable_colors.map((c) => new Vector3(...c)),
  flower_plant_o.min_w,
);

let custom_o = {
  grammar: {
    F: [["F F", 1]],
  },
  axiom: "F",
  start_position: [0, 0, 0],
  start_rotation: [0, 0, 1, 0, 1, 0, 1, 0, 0],
  start_width: 1,
  start_color: [255, 255, 255],
  step_size: 1,
  angle: 0,
  width_increment: 0,
  starting_width_increment: 0,
  addressable_colors: [],
  min_w: 0,
};
let custom = new LSystem(
  custom_o.axiom,
  custom_o.grammar,
  new Vector3(...custom_o.start_position),
  new Mat3(custom_o.start_rotation),
  custom_o.start_width,
  new Vector3(...custom_o.start_color),
  custom_o.step_size,
  custom_o.angle,
  custom_o.width_increment,
  custom_o.starting_width_increment,
  custom_o.addressable_colors.map((c) => new Vector3(...c)),
  custom_o.min_w,
);
